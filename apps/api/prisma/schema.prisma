// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(cuid())
  email       String   @unique
  password    String
  role        UserRole
  firstName   String   @map("first_name")
  lastName    String   @map("last_name")
  phone       String?
  avatar      String?
  bio         String?
  location    String?
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  organizedEvents    Event[]               @relation("EventOrganizer")
  approvedEvents     Event[]               @relation("EventApprover")
  participations     EventParticipant[]
  channelPosts       ChannelPost[]
  postLikes          PostLike[]
  postComments       PostComment[]
  pushSubscriptions  PushSubscription[]
  notifications      NotificationLog[]

  @@map("users")
}

model Event {
  id              String      @id @default(cuid())
  title           String
  description     String
  location        String
  startDate       DateTime    @map("start_date")
  endDate         DateTime    @map("end_date")
  capacity        Int?
  category        String
  status          EventStatus @default(PENDING)
  organizerId     String      @map("organizer_id")
  approvedBy      String?     @map("approved_by")
  approvedAt      DateTime?   @map("approved_at")
  rejectionReason String?     @map("rejection_reason")
  createdAt       DateTime    @default(now()) @map("created_at")
  updatedAt       DateTime    @updatedAt @map("updated_at")

  // Relations
  organizer             User                    @relation("EventOrganizer", fields: [organizerId], references: [id])
  approver              User?                   @relation("EventApprover", fields: [approvedBy], references: [id])
  participants          EventParticipant[]
  communicationChannel  CommunicationChannel?

  @@map("events")
}

model EventParticipant {
  id              String                    @id @default(cuid())
  eventId         String                    @map("event_id")
  volunteerId     String                    @map("volunteer_id")
  status          EventParticipantStatus    @default(PENDING)
  registeredAt    DateTime                  @default(now()) @map("registered_at")
  completedAt     DateTime?                 @map("completed_at")
  rejectionReason String?                   @map("rejection_reason")
  rating          Int?                      // 1-5 stars
  feedback        String?                   
  ratedAt         DateTime?                 @map("rated_at")

  // Relations
  event     Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  volunteer User  @relation(fields: [volunteerId], references: [id], onDelete: Cascade)

  @@unique([eventId, volunteerId])
  @@map("event_participants")
}

model CommunicationChannel {
  id        String   @id @default(cuid())
  eventId   String   @unique @map("event_id")
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  event Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  posts ChannelPost[]

  @@map("communication_channels")
}

model ChannelPost {
  id        String   @id @default(cuid())
  channelId String   @map("channel_id")
  authorId  String   @map("author_id")
  content   String
  imageUrl  String?  @map("image_url")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  channel  CommunicationChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  author   User                 @relation(fields: [authorId], references: [id], onDelete: Cascade)
  likes    PostLike[]
  comments PostComment[]

  @@map("channel_posts")
}

model PostLike {
  id     String @id @default(cuid())
  postId String @map("post_id")
  userId String @map("user_id")

  // Relations
  post ChannelPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@map("post_likes")
}

model PostComment {
  id        String   @id @default(cuid())
  postId    String   @map("post_id")
  authorId  String   @map("author_id")
  content   String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  post   ChannelPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  author User        @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@map("post_comments")
}

model PushSubscription {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  endpoint  String
  p256dhKey String   @map("p256dh_key")
  authKey   String   @map("auth_key")
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, endpoint])
  @@map("push_subscriptions")
}

model NotificationLog {
  id        String           @id @default(cuid())
  userId    String           @map("user_id")
  type      NotificationType
  title     String
  body      String
  data      Json?            // Store notification data as JSON
  isRead    Boolean          @default(false) @map("is_read")
  readAt    DateTime?        @map("read_at")
  createdAt DateTime         @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@map("notification_logs")
}

enum NotificationType {
  EVENT_APPROVAL_REQUIRED
  EVENT_STATUS_CHANGE
  NEW_REGISTRATION
  REGISTRATION_STATUS_CHANGE
}

enum UserRole {
  VOLUNTEER
  ORGANIZER
  ADMIN
}

enum EventStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

enum EventParticipantStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}